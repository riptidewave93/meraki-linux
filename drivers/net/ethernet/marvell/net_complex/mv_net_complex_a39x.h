/******************************************************************************
*Copyright (C) Marvell International Ltd. and its affiliates
*
*This software file (the "File") is owned and distributed by Marvell
*International Ltd. and/or its affiliates ("Marvell") under the following
*alternative licensing terms.  Once you have made an election to distribute the
*File under one of the following license alternatives, please (i) delete this
*introductory statement regarding license alternatives, (ii) delete the two
*license alternatives that you have not elected to use and (iii) preserve the
*Marvell copyright notice above.
*
******************************************************************************
*Marvell GPL License Option
*
*If you received this File from Marvell, you may opt to use, redistribute and/or
*modify this File in accordance with the terms and conditions of the General
*Public License Version 2, June 1991 (the "GPL License"), a copy of which is
*available along with the File in the license.txt file or on the worldwide web
*at http://www.gnu.org/licenses/gpl.txt.
*
*THE FILE IS DISTRIBUTED AS-IS, WITHOUT WARRANTY OF ANY KIND, AND THE IMPLIED
*WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE ARE EXPRESSLY
*DISCLAIMED.  The GPL License provides additional details about this warranty
*disclaimer.
******************************************************************************/

#ifndef LINUX_MV_NETCOMPLEX_A39X_H
#define LINUX_MV_NETCOMPLEX_A39X_H

#define MV_NET_COMPLEX_NAME		"mv_net_complex"
#define MV_NET_COMPLEX_OFFSET		(mv_net_complex_vbase_addr)
#define MV_MISC_REGS_OFFSET             (mv_net_complex_misc_vbase_addr)
#define MV_COMMON_PHY_REGS_OFFSET       (mv_net_complex_phy_vbase_addr)
#define MV_IP_CONFIG_REGS_OFFSET        (mv_net_complex_phy_vbase_addr + 0x100)

enum mv_net_complex_topology {
	MV_NETCOMP_GE_MAC0_2_RXAUI	=	BIT(0),
	MV_NETCOMP_GE_MAC0_2_XAUI	=	BIT(1),
	MV_NETCOMP_GE_MAC0_2_SGMII_L0	=	BIT(2),
	MV_NETCOMP_GE_MAC0_2_SGMII_L1	=	BIT(3),
	MV_NETCOMP_GE_MAC0_2_QSGMII	=	BIT(4),
	MV_NETCOMP_GE_MAC1_2_SGMII_L1	=	BIT(5),
	MV_NETCOMP_GE_MAC1_2_RGMII1	=	BIT(6),
	MV_NETCOMP_GE_MAC1_2_SGMII_L2	=	BIT(7),
	MV_NETCOMP_GE_MAC1_2_SGMII_L4	=	BIT(8),
	MV_NETCOMP_GE_MAC1_2_QSGMII	=	BIT(9),
	MV_NETCOMP_GE_MAC2_2_SGMII_L3	=	BIT(10),
	MV_NETCOMP_GE_MAC2_2_SGMII_L5	=	BIT(11),
	MV_NETCOMP_GE_MAC2_2_QSGMII	=	BIT(12),
	MV_NETCOMP_GE_MAC3_2_SGMII_L4	=	BIT(13),
	MV_NETCOMP_GE_MAC3_2_SGMII_L6	=	BIT(14),
	/* relevant for A0 */
	MV_NETCOMP_GE_MAC3_2_QSGMII	=	BIT(15),
	MV_NETCOMP_GE_MAC0_2_SGMII_L6	=	BIT(16)
};

enum mv_net_complex_phase {
	MV_NETC_FIRST_PHASE,
	MV_NETC_SECOND_PHASE,
};

enum mv_net_complex_gbe1_mode {
	MV_NETC_GBE1_SGMII,
	MV_NETC_GBE1_RGMII,
};

/******************************************************************************/
/* Power management clock control1 */
#define MV_NETCOMP_CLOCK_GATING				(MV_NET_COMPLEX_OFFSET)

#define NETC_CLOCK_GATING_SRAM_X2_OFFSET		8
#define NETC_CLOCK_GATING_SRAM_X2_MASK			(0x1 << NETC_CLOCK_GATING_SRAM_X2_OFFSET)

#define NETC_CLOCK_GATING_SRAM_OFFSET			9
#define NETC_CLOCK_GATING_SRAM_MASK			(0x1 << NETC_CLOCK_GATING_SRAM_OFFSET)

#define NETC_CLOCK_GATING_PPC_CMAC_OFFSET		10
#define NETC_CLOCK_GATING_PPC_CMAC_MASK			(0x1 << NETC_CLOCK_GATING_PPC_CMAC_OFFSET)

#define NETC_CLOCK_GATING_PPC_PP_OFFSET			11
#define NETC_CLOCK_GATING_PPC_PP_MASK			(0x1 << NETC_CLOCK_GATING_PPC_PP_OFFSET)

#define NETC_CLOCK_GATING_PPC_NSS_OFFSET		12
#define NETC_CLOCK_GATING_PPC_NSS_MASK			(0x1 << NETC_CLOCK_GATING_PPC_NSS_OFFSET)

#define NETC_CLOCK_GATING_CMAC_OFFSET			13
#define NETC_CLOCK_GATING_CMAC_MASK			(0x1 << NETC_CLOCK_GATING_CMAC_OFFSET)

#define NETC_CLOCK_GATING_NSS_OFFSET			14
#define NETC_CLOCK_GATING_NSS_MASK			(0x1 << NETC_CLOCK_GATING_NSS_OFFSET)

#define NETC_CLOCK_GATING_QM2_OFFSET			15
#define NETC_CLOCK_GATING_QM2_MASK			(0x1 << NETC_CLOCK_GATING_QM2_OFFSET)

#define NETC_CLOCK_GATING_QM1_X2_OFFSET			16
#define NETC_CLOCK_GATING_QM1_X2_MASK			(0x1 << NETC_CLOCK_GATING_QM1_X2_OFFSET)

#define NETC_CLOCK_GATING_QM1_OFFSET			17
#define NETC_CLOCK_GATING_QM1_MASK			(0x1 << NETC_CLOCK_GATING_QM1_OFFSET)

/* System Soft Reset */
#define MV_NETCOMP_SYSTEM_SOFT_RESET			(MV_NET_COMPLEX_OFFSET + 0x8)

#define NETC_GOP_SOFT_RESET_OFFSET			6
#define NETC_GOP_SOFT_RESET_MASK			(0x1 << NETC_GOP_SOFT_RESET_OFFSET)

#define NETC_GOP_SW_LOAD_CONF_OFFSET			8
#define NETC_GOP_SW_LOAD_CONF_MASK			(0x1 << NETC_GOP_SW_LOAD_CONF_OFFSET)

#define NETC_NSS_SRAM_SOFT_RESET_OFFSET			9
#define NETC_NSS_SRAM_SOFT_RESET_MASK			(0x1 << NETC_NSS_SRAM_SOFT_RESET_OFFSET)

#define NETC_NSS_SRAM_LOAD_CONF_OFFSET			10
#define NETC_NSS_SRAM_LOAD_CONF_MASK			(0x1 << NETC_NSS_SRAM_LOAD_CONF_OFFSET)

#define NETC_NSS_PPC_SOFT_RESET_OFFSET			11
#define NETC_NSS_PPC_SOFT_RESET_MASK			(0x1 << NETC_NSS_PPC_SOFT_RESET_OFFSET)

#define NETC_NSS_PPC_LOAD_CONF_OFFSET			12
#define NETC_NSS_PPC_LOAD_CONF_MASK			(0x1 << NETC_NSS_PPC_LOAD_CONF_OFFSET)

#define NETC_NSS_MACS_SOFT_RESET_OFFSET			13
#define NETC_NSS_MACS_SOFT_RESET_MASK			(0x1 << NETC_NSS_MACS_SOFT_RESET_OFFSET)

#define NETC_NSS_MACS_LOAD_CONF_OFFSET			14
#define NETC_NSS_MACS_LOAD_CONF_MASK			(0x1 << NETC_NSS_MACS_LOAD_CONF_OFFSET)

#define NETC_NSS_QM2_SOFT_RESET_OFFSET			15
#define NETC_NSS_QM2_SOFT_RESET_MASK			(0x1 << NETC_NSS_QM2_SOFT_RESET_OFFSET)

#define NETC_NSS_QM1_SOFT_RESET_OFFSET			16
#define NETC_NSS_QM1_SOFT_RESET_MASK			(0x1 << NETC_NSS_QM1_SOFT_RESET_OFFSET)

#define NETC_NSS_QM1_LOAD_CONF_OFFSET			17
#define NETC_NSS_QM1_LOAD_CONF_MASK			(0x1 << NETC_NSS_QM1_LOAD_CONF_OFFSET)

/* Ports Control 0 */
#define MV_NETCOMP_PORTS_CONTROL_0			(MV_NET_COMPLEX_OFFSET + 0x10)

#define NETC_CLK_DIV_PHASE_OFFSET			31
#define NETC_CLK_DIV_PHASE_MASK				(0x1 << NETC_CLK_DIV_PHASE_OFFSET)

#define NETC_GIG_RX_DATA_SAMPLE_OFFSET			29
#define NETC_GIG_RX_DATA_SAMPLE_MASK			(0x1 << NETC_GIG_RX_DATA_SAMPLE_OFFSET)

#define NETC_BUS_WIDTH_SELECT_OFFSET			1
#define NETC_BUS_WIDTH_SELECT_MASK			(0x1 << NETC_BUS_WIDTH_SELECT_OFFSET)

/* Ports Control 1 */
#define MV_NETCOMP_PORTS_CONTROL_1			(MV_NET_COMPLEX_OFFSET + 0x14)

#define NETC_PORT_GIG_RF_RESET_OFFSET(port)		(28 + port)
#define NETC_PORT_GIG_RF_RESET_MASK(port)		(0x1 << NETC_PORT_GIG_RF_RESET_OFFSET(port))

#define NETC_PORTS_ACTIVE_OFFSET(port)			(0 + port)
#define NETC_PORTS_ACTIVE_MASK(port)			(0x1 << NETC_PORTS_ACTIVE_OFFSET(port))

/* Networking Complex Control 0 */
#define MV_NETCOMP_CONTROL_0				(MV_NET_COMPLEX_OFFSET + 0x20)

#define NETC_CTRL_ENA_XAUI_OFFSET			11
#define NETC_CTRL_ENA_XAUI_MASK				(0x1 << NETC_CTRL_ENA_XAUI_OFFSET)

#define NETC_CTRL_ENA_RXAUI_OFFSET			10
#define NETC_CTRL_ENA_RXAUI_MASK			(0x1 << NETC_CTRL_ENA_RXAUI_OFFSET)

#define NETC_GBE_PORT1_MODE_OFFSET			1
#define NETC_GBE_PORT1_MODE_MASK			(0x1 << NETC_GBE_PORT1_MODE_OFFSET)

/* Networking Complex AMB Access Control 0 */
#define MV_NETCOMP_AMB_ACCESS_CTRL_0			(MV_NET_COMPLEX_OFFSET + 0xC0)

#define NETC_AMB_ACCESS_CTRL_OFFSET			24
#define NETC_AMB_ACCESS_CTRL_MASK			(0xff << NETC_AMB_ACCESS_CTRL_OFFSET)

/* QSGMII Control 1 */
#define MV_NETCOMP_QSGMII_CTRL_1			(MV_IP_CONFIG_REGS_OFFSET + 0x94)

#define NETC_QSGMII_CTRL_RSTN_OFFSET			31
#define NETC_QSGMII_CTRL_RSTN_MASK			(0x1 << NETC_QSGMII_CTRL_RSTN_OFFSET)

#define NETC_QSGMII_CTRL_ACTIVE_OFFSET			30
#define NETC_QSGMII_CTRL_ACTIVE_MASK			(0x1 << NETC_QSGMII_CTRL_ACTIVE_OFFSET)

#define NETC_QSGMII_CTRL_V3ACTIVE_OFFSET		29
#define NETC_QSGMII_CTRL_V3ACTIVE_MASK			(0x1 << NETC_QSGMII_CTRL_V3ACTIVE_OFFSET)

#define NETC_QSGMII_CTRL_VERSION_OFFSET			28
#define NETC_QSGMII_CTRL_VERSION_MASK			(0x1 << NETC_QSGMII_CTRL_VERSION_OFFSET)

/* Function Enable Control 1 */
#define MV_NETCOMP_FUNCTION_ENABLE_CTRL_1			(MV_MISC_REGS_OFFSET + 0x88)

#define NETC_PACKET_PROCESS_OFFSET			1
#define NETC_PACKET_PROCESS_MASK			(0x1 << NETC_PACKET_PROCESS_OFFSET)

/* ComPhy Selector */
#define COMMON_PHYS_SELECTORS_REG			(MV_COMMON_PHY_REGS_OFFSET + 0xFC)

#define COMMON_PHYS_SELECTOR_LANE_OFFSET(lane)		(4 * lane)
#define COMMON_PHYS_SELECTOR_LANE_MASK(lane)		(0xF << COMMON_PHYS_SELECTOR_LANE_OFFSET(lane))

#define COMMON_PHYS_SELECTOR_LANE_0_GBE_PORT0		(0x3)
#define COMMON_PHYS_SELECTOR_LANE_0_GBE_V3_PORT0	(0x4)

#define COMMON_PHYS_SELECTOR_LANE_1_GBE_PORT0		(0x4 << COMMON_PHYS_SELECTOR_LANE_OFFSET(1))
#define COMMON_PHYS_SELECTOR_LANE_1_GBE_V3_PORT0	(0x8 << COMMON_PHYS_SELECTOR_LANE_OFFSET(1))
#define COMMON_PHYS_SELECTOR_LANE_1_GBE_PORT1		(0x5 << COMMON_PHYS_SELECTOR_LANE_OFFSET(1))
#define COMMON_PHYS_SELECTOR_LANE_1_GBE_V3_PORT1	(0x9 << COMMON_PHYS_SELECTOR_LANE_OFFSET(1))
#define COMMON_PHYS_SELECTOR_LANE_1_QSGMII		(0x7 << COMMON_PHYS_SELECTOR_LANE_OFFSET(1))

#define COMMON_PHYS_SELECTOR_LANE_2_GBE_PORT1		(0x4 << COMMON_PHYS_SELECTOR_LANE_OFFSET(2))
#define COMMON_PHYS_SELECTOR_LANE_2_GBE_V3_PORT1	(0x5 << COMMON_PHYS_SELECTOR_LANE_OFFSET(2))

#define COMMON_PHYS_SELECTOR_LANE_3_GBE_PORT2		(0x4 << COMMON_PHYS_SELECTOR_LANE_OFFSET(3))
#define COMMON_PHYS_SELECTOR_LANE_3_GBE_V3_PORT2	(0x7 << COMMON_PHYS_SELECTOR_LANE_OFFSET(3))
#define COMMON_PHYS_SELECTOR_LANE_3_XAUI_PORT3		(0x8 << COMMON_PHYS_SELECTOR_LANE_OFFSET(3))

#define COMMON_PHYS_SELECTOR_LANE_4_GBE_PORT1		(0x3 << COMMON_PHYS_SELECTOR_LANE_OFFSET(4))
#define COMMON_PHYS_SELECTOR_LANE_4_GBE_V3_PORT3	(0x8 << COMMON_PHYS_SELECTOR_LANE_OFFSET(4))
#define COMMON_PHYS_SELECTOR_LANE_4_XAUI_PORT2		(0x9 << COMMON_PHYS_SELECTOR_LANE_OFFSET(4))

#define COMMON_PHYS_SELECTOR_LANE_5_GBE_PORT2		(0x3 << COMMON_PHYS_SELECTOR_LANE_OFFSET(5))
#define COMMON_PHYS_SELECTOR_LANE_5_GBE_V3_PORT2	(0x6 << COMMON_PHYS_SELECTOR_LANE_OFFSET(5))
#define COMMON_PHYS_SELECTOR_LANE_5_XAUI_PORT1		(0x8 << COMMON_PHYS_SELECTOR_LANE_OFFSET(5))

#define COMMON_PHYS_SELECTOR_LANE_6_GBE_V3_PORT3	(0x2 << COMMON_PHYS_SELECTOR_LANE_OFFSET(6))
#define COMMON_PHYS_SELECTOR_LANE_6_GBE_V3_PORT0	(0xc << COMMON_PHYS_SELECTOR_LANE_OFFSET(6))
#define COMMON_PHYS_SELECTOR_LANE_6_XAUI_PORT0		(0x4 << COMMON_PHYS_SELECTOR_LANE_OFFSET(6))

/* DFX Server Reset Control register */
#define MV_DFX_SERVER_RESET_REG_OFFSET			(mv_net_dfx_vbase_addr + 0xC)
#define MV_DFX_SERVER_RESET_TABLE_START_INIT_MASK	(0x1 << 2)

int mv_net_complex_dynamic_init(enum mv_net_complex_topology lane_mode);
int mv_net_complex_init(u32 net_comp_config, enum mv_net_complex_phase phase);
void mv_net_complex_nss_select(u32 val);
void mv_nss_sw_reset(void);

#endif /* LINUX_MV_NETCOMPLEX_A39X_H */
